<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pink Sky Checker</title>
<style>
  :root{
    --page-top:#eaf5ff;
    --page-bottom:#fff4fb;
    --card:#ffffff;
    --ink:#061425;
    --muted:#667085;
    --accent-pink:#ff6fb5;
    --accent-blue:#6e93ff;
    --accent-purple:#9a7bff;
    --soft-border: rgba(8,15,40,0.06);
    --shadow: 0 12px 34px rgba(8,18,40,0.10);
    --pill-bg: rgba(139,92,246,0.08);
  }
  html,body{height:100%}
  body{
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    margin:0; min-height:100%;
    background: linear-gradient(180deg,var(--page-top),var(--page-bottom));
    color:var(--ink); -webkit-font-smoothing:antialiased;
    line-height:1.45; padding:34px 16px;
    position:relative;
    overflow-y:auto;
  }

  /* Decorative fluffy clouds (subtle, behind everything) */
  .bg-cloud { position: absolute; opacity: 0.12; pointer-events: none; }
  .bg-cloud.c1 { top: 8px; left: -40px; width: 340px; transform: rotate(-6deg); }
  .bg-cloud.c2 { top: 120px; right: -60px; width: 420px; transform: scaleX(-1) rotate(4deg); }
  .bg-cloud.c3 { bottom: -30px; left: 10px; width: 380px; opacity: 0.08; }

  /* TITLE outside the card (big, bubble gradient + subtle 3D) */
  .title-wrap{max-width:760px;margin:0 auto 16px; text-align:left; position:relative; z-index:2;}
  .title {
    display:inline-block;
    padding:12px 20px;
    border-radius:28px;
    font-weight:900;
    font-size:34px;
    letter-spacing:-0.02em;
    line-height:1;
    color:transparent;
    -webkit-background-clip:text;
    background-clip:text;
    background-image: linear-gradient(90deg, var(--accent-pink), var(--accent-purple), var(--accent-blue));
    text-shadow: 0 10px 28px rgba(107,119,255,0.09);
  }

  /* CARD */
  .card{max-width:760px;margin:14px auto;padding:18px;border-radius:16px;background:var(--card);box-shadow:var(--shadow);border:1px solid var(--soft-border);position:relative;z-index:2}
  h2{margin:0 0 8px;font-size:15px;color:var(--ink);font-weight:800}
  .lead{color:var(--muted);margin-bottom:10px;font-size:15px}

  label{display:block;margin:8px 0 6px;font-weight:700;color:var(--ink);font-size:14px}
  input[type="text"]{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(99,102,241,0.06);outline:none;font-size:15px}
  input[type="text"]::placeholder{color:#c7cfda}
  .row{display:flex;gap:10px;align-items:center}
  button.primary{
    padding:12px 14px;border-radius:12px;border:0;color:white;font-weight:800;cursor:pointer;
    background: linear-gradient(90deg,var(--accent-pink),var(--accent-purple),var(--accent-blue));
    box-shadow: 0 10px 28px rgba(107,119,255,0.14);
    min-width:96px;
    transition:transform .12s ease;
  }
  button.primary:active{ transform:translateY(1px) scale(.997); }

  select{padding:10px;border-radius:10px;border:1px solid rgba(99,102,241,0.06);background:white;font-size:15px}

  .result{
    margin-top:14px;padding:16px;border-radius:12px;background:linear-gradient(180deg, rgba(243,250,255,0.85), rgba(255,248,252,0.85));
    border:1px solid rgba(99,102,241,0.05);
    font-size:15px;
  }

  /* verdict styling ‚Äî bigger, with playful tagline */
  .verdict {
    font-weight:900;
    font-size:18px;
    margin-bottom:6px;
  }
  .verdict .tagline { display:block; font-weight:600; font-size:13px; margin-top:6px; color:var(--muted) }

  .good { color: var(--accent-blue); }
  .meh { color: var(--accent-purple); }
  .bad { color: var(--accent-pink); }

  .details{color:var(--muted);margin-top:8px;font-size:14px}
  .notes{font-size:13px;color:var(--muted);margin-top:10px}

  .tips{margin-top:12px;font-size:14px;background: linear-gradient(90deg, rgba(255,244,248,0.6), rgba(237,245,255,0.6));padding:12px;border-radius:10px;border:1px solid rgba(107,119,255,0.06)}
  a.ics{display:inline-block;margin-top:10px;color:var(--ink);text-decoration:none;padding:8px 10px;border-radius:8px;background:rgba(139,92,246,0.08);font-weight:700}

  .confidence{margin-top:10px;font-size:13px;color:var(--muted);display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .conf-pill{padding:6px 10px;border-radius:999px;background:linear-gradient(90deg, rgba(107,119,255,0.10), rgba(255,111,181,0.06));font-weight:700;color:var(--muted);font-size:13px}
  .conf-extra{font-size:12px;color:var(--muted)}

  .error{color:var(--accent-pink);font-weight:800}
  @media(max-width:720px){
    .row{flex-direction:column;align-items:stretch}
    .primary{width:100%}
    select{width:100%}
    input[type="text"]{width:100%}
    .title{font-size:28px}
  }

  footer{max-width:760px;margin:18px auto 60px;color:var(--muted);text-align:center;font-size:13px;position:relative;z-index:2}
</style>
</head>
<body>

  <!-- fluffy SVG clouds (decorative) -->
  <svg class="bg-cloud c1" viewBox="0 0 512 128" xmlns="http://www.w3.org/2000/svg"><g fill="#fff"><ellipse cx="110" cy="64" rx="110" ry="40"/><ellipse cx="240" cy="54" rx="76" ry="34"/><ellipse cx="360" cy="62" rx="100" ry="36"/></g></svg>
  <svg class="bg-cloud c2" viewBox="0 0 512 128" xmlns="http://www.w3.org/2000/svg"><g fill="#fff"><ellipse cx="110" cy="64" rx="110" ry="40"/><ellipse cx="240" cy="54" rx="76" ry="34"/><ellipse cx="360" cy="62" rx="100" ry="36"/></g></svg>
  <svg class="bg-cloud c3" viewBox="0 0 512 128" xmlns="http://www.w3.org/2000/svg"><g fill="#fff"><ellipse cx="110" cy="64" rx="110" ry="40"/><ellipse cx="240" cy="54" rx="76" ry="34"/><ellipse cx="360" cy="62" rx="100" ry="36"/></g></svg>

  <!-- TITLE outside the card -->
  <div class="title-wrap">
    <div class="title" role="heading" aria-level="1">Pink Sky Checker</div>
  </div>

  <div class="card" role="main" aria-labelledby="title">
    <h2 id="title-sub">Location & Day</h2>
    <div class="lead">Choose a location and day ‚Äî the checker gives a friendly verdict and the best minute to step outside for colorful afterglow (and photo karma).</div>

    <label for="manual">Location & Day</label>
    <div class="row" aria-hidden="false">
      <button id="btnGeo" class="primary" aria-label="Use my location (fast)">Use my location</button>
      <input id="manual" placeholder="City, ST or lat,lon (e.g. Chevy Chase, MD or 38.9854,-77.0701)" aria-label="Location input" />
      <select id="daySelect" title="Choose day"></select>
    </div>

    <div style="margin-top:12px;display:flex;gap:10px">
      <button id="btnCheck" class="primary" style="flex:1">Check</button>
    </div>

    <div id="output" class="result" style="display:none" role="status" aria-live="polite"></div>

    <div id="after" style="display:none">
      <div class="tips" id="tips" aria-hidden="true">
        <div><strong>Photo tips:</strong> arrive at <span id="bestTimeLabel"></span>. Tap focus on your phone, drag exposure down a notch, use Live Photo or burst. <br><small>If the verdict is ‚ÄúCarrot-ready,‚Äù expect the peak ~10‚Äì20 minutes after sunset.</small></div>
        <a id="icsLink" class="ics" download="pink-sky-reminder.ics" style="display:none" aria-hidden="false">üìÖ Download reminder</a>
      </div>
      <div class="notes" id="notes" style="display:none"></div>
    </div>
  </div>

  <footer>
    <div>Made with soft clouds and stubborn optimism ‚òÅÔ∏è</div>
  </footer>

<script>
/* ----------------- same app logic, but friendlier labels + multi-word descriptors ----------------- */

/* storage */
const STORAGE_KEY = 'pinksky_saved_location';
function saveLocationToStorage(name, lat, lon){
  try{ localStorage.setItem(STORAGE_KEY, JSON.stringify({name, lat, lon})); } catch(e){ console.warn('storage fail', e); }
}
function loadLocationFromStorage(){
  try{
    const s = localStorage.getItem(STORAGE_KEY);
    if(!s) return null;
    const obj = JSON.parse(s);
    if(obj && typeof obj.lat === 'number' && typeof obj.lon === 'number') return obj;
  } catch(e){ console.warn('load fail', e); }
  return null;
}

/* UI helpers */
function addDays(date, n){ const d=new Date(date); d.setDate(d.getDate()+n); return d; }
function weekdayShort(d){ return d.toLocaleDateString(undefined,{weekday:'short'}); }
function monthDay(d){ return (d.getMonth()+1)+'/'+d.getDate(); }
function populateDaySelect() {
  const sel = document.getElementById('daySelect'); sel.innerHTML=''; const now = new Date();
  for (let i=0;i<7;i++){
    const dt = addDays(now,i);
    const label = (i===0? 'Today' : (i===1? 'Tomorrow' : weekdayShort(dt))) + ' (' + monthDay(dt) + ')';
    const opt = document.createElement('option'); opt.value = String(i); opt.textContent = label; sel.appendChild(opt);
  }
}
populateDaySelect();

function nearestIndex(timesISO, targetDate) {
  let best = 0, bestDiff = Infinity;
  for (let i=0;i<timesISO.length;i++){
    const d = Math.abs(new Date(timesISO[i]).getTime() - targetDate.getTime());
    if (d < bestDiff) { bestDiff = d; best = i; }
  }
  return best;
}

/* API helpers + fallback URLs */
function buildUrls(lat, lon) {
  const base = (fields) => `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=sunrise,sunset&hourly=${fields}&timezone=auto`;
  return [
    base('cloudcover,cloudcover_high,cloudcover_mid,cloudcover_low,pm2_5'),
    base('cloudcover,pm2_5'),
    base('cloudcover')
  ];
}
async function tryFetchUrls(urls) {
  for (const u of urls) {
    try {
      const r = await fetch(u);
      const j = await r.json();
      if (j && j.daily && j.hourly && j.hourly.time && j.hourly.time.length) {
        if (j.hourly.cloudcover || j.hourly.cloudcover === 0) return j;
      }
    } catch(e) { console.warn('fetch fail', e); }
  }
  return null;
}

/* friendly, local QA + text helpers */
function airQualityLabel(pm2){
  if(pm2==null) return null;
  if(pm2 <= 12) return 'Good';
  if(pm2 <= 35) return 'Moderate';
  return 'Poor';
}

/* convert numeric score to human-friendly confidence + witty tagline */
function confidenceLabel(score){
  if (score >= 4) return {label:'High', emoji:'‚ú®', text:'Carrot-ready ‚Äî vivid color likely! Make space on your camera roll.'};
  if (score >= 1.5) return {label:'Medium', emoji:'üå§Ô∏è', text:'Possible ‚Äî thin high clouds might turn into a pretty wash of color.'};
  return {label:'Low', emoji:'‚òÅÔ∏è', text:'Unlikely ‚Äî thick clouds or reduced visibility will mute the sunset.'};
}

/* main check logic */
async function check(lat, lon, displayName) {
  const out = document.getElementById('output');
  out.style.display = 'block';
  out.textContent = 'Fetching forecast‚Ä¶';
  document.getElementById('after').style.display = 'none';

  try {
    const urls = buildUrls(lat, lon);
    const json = await tryFetchUrls(urls);

    if (!json) {
      out.innerHTML = `<div class="error">Forecast data unavailable for that spot.</div>`;
      return;
    }

    const dayIndex = parseInt(document.getElementById('daySelect').value || '0', 10);
    if (!json.daily || !json.daily.sunset || dayIndex >= json.daily.sunset.length) {
      out.innerHTML = `<div class="error">Forecast for that day is not available from the API. Try a nearer day.</div>`;
      return;
    }

    // Save successful location
    const nameToSave = displayName || document.getElementById('manual').value.trim() || `${lat.toFixed(4)},${lon.toFixed(4)}`;
    saveLocationToStorage(nameToSave, lat, lon);

    const sunsetLocal = new Date(json.daily.sunset[dayIndex]);
    const times = json.hourly.time;
    const idx = nearestIndex(times, sunsetLocal);

    const cloud = json.hourly.cloudcover ? json.hourly.cloudcover[idx] : null;
    const chigh = json.hourly.cloudcover_high ? json.hourly.cloudcover_high[idx] : null;
    const cmid = json.hourly.cloudcover_mid ? json.hourly.cloudcover_mid[idx] : null;
    const clow = json.hourly.cloudcover_low ? json.hourly.cloudcover_low[idx] : null;
    const pm2 = json.hourly.pm2_5 ? json.hourly.pm2_5[idx] : null;

    // scoring (unchanged)
    let score = 0;
    if (chigh !== null) {
      if (chigh >= 15 && chigh <= 85) score += 2;
      else if (chigh > 85) score -= 1;
      else score += 0.5;
    }
    if (cmid !== null) {
      if (cmid >= 10 && cmid <= 80) score += 1.5;
      else if (cmid > 80) score -= 1;
    }
    if (clow !== null) {
      if (clow <= 30) score += 1;
      else score -= 1.5;
    }
    if (cloud !== null) {
      if (cloud >= 10 && cloud <= 80) score += 1;
      else if (cloud === 0) score -= 0.8;
      else if (cloud > 90) score -= 1.2;
    }
    if (pm2 !== null) {
      if (pm2 <= 12) score += 1.2;
      else if (pm2 <= 35) score += 0.2;
      else score -= 1.2;
    }

    // produce friendly reason (multi-word, local-ish)
    let reason = null;
    if (clow !== null && clow > 50) reason = 'thick low clouds';
    else if (cloud !== null && cloud > 90) reason = 'widespread overcast';
    else if (pm2 !== null && pm2 > 35) reason = 'reduced air quality / haze';
    else if (chigh !== null && chigh > 60 && cloud < 90) reason = 'mostly high clouds (may mute colors)';
    else reason = 'not quite right for afterglow';

    // friendly verdict text (multi-word + small tagline)
    let verdictText = '', verdictClass = 'meh', tagline = '';
    if (score >= 4) {
      verdictText = 'Carrot-ready ‚Äî vivid pink & blue likely';
      verdictClass = 'good';
      tagline = 'Drop everything: that one minute after sunset is for the books.';
    } else if (score >= 1.5) {
      verdictClass = 'meh';
      if ((chigh !== null && chigh >= 15 && chigh <= 85) || (cmid !== null && cmid >= 10 && cmid <= 80)) {
        verdictText = 'Possible ‚Äî thin high clouds might catch the sun';
        tagline = 'Pack your camera: could be pleasantly painterly.';
      } else {
        verdictText = 'Possible ‚Äî worth checking';
        tagline = 'Keep an eye on the western sky around sunset.';
      }
    } else {
      verdictText = `Unlikely ‚Äî ${reason}`;
      verdictClass = 'bad';
      tagline = 'No doom: take a walk anyway. Cloud selfies count too.';
    }

    const conf = confidenceLabel(score);

    // readable details
    const details = [];
    if (cloud !== null) details.push(`Cloud cover: ${Math.round(cloud)}%`);
    if (chigh !== null) details.push(`High clouds: ${Math.round(chigh)}%`);
    if (cmid !== null) details.push(`Mid clouds: ${Math.round(cmid)}%`);
    if (clow !== null) details.push(`Low clouds: ${Math.round(clow)}%`);
    if (pm2 !== null) details.push(`Air quality: ${airQualityLabel(pm2)} (${Math.round(pm2)} ¬µg/m¬≥)`);

    const best = new Date(sunsetLocal.getTime() + 10*60000);

    out.innerHTML = `
      <div class="verdict ${verdictClass}">${verdictText}<span class="tagline"> ‚Äî ${tagline}</span></div>
      <div class="details"><small>Sunset: ${sunsetLocal.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})} ¬∑ Best check: ${best.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</small></div>
      <div class="details" style="margin-top:8px">${details.join(' ¬∑ ')}</div>
      <div class="confidence"><div class="conf-pill">${conf.emoji} Confidence: ${conf.label}</div><div class="conf-extra">based on cloud layers & air quality (numeric score hidden)</div></div>
    `;

    document.getElementById('after').style.display = 'block';
    document.getElementById('tips').style.display = 'block';
    document.getElementById('notes').style.display = 'block';
    document.getElementById('bestTimeLabel').textContent = best.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});
    document.getElementById('notes').textContent = conf.text;

    const ics = makeICS(best);
    const blob = new Blob([ics], {type:'text/calendar'});
    const urlBlob = URL.createObjectURL(blob);
    const icsLink = document.getElementById('icsLink');
    icsLink.href = urlBlob;
    icsLink.style.display = 'inline-block';

  } catch (err) {
    console.error(err);
    out.innerHTML = '<span class="error">Error fetching forecast. Check your internet and try again.</span>';
  }
}

/* geocode + stored-name reuse (same as before) */
async function fetchCoordsFromText(text) {
  const latlon = text.match(/(-?\d+\.\d+)\s*,\s*(-?\d+\.\d+)/);
  if (latlon) return {lat: +latlon[1], lon: +latlon[2], name: `${+latlon[1].toFixed(4)},${+latlon[2].toFixed(4)}`};
  const saved = loadLocationFromStorage();
  if (saved && saved.name === text) return {lat: saved.lat, lon: saved.lon, name: saved.name};
  try {
    const q = encodeURIComponent(text);
    const url = `https://nominatim.openstreetmap.org/search?q=${q}&format=json&limit=1`;
    const r = await fetch(url, {headers: {'Accept-Language':'en'}});
    const j = await r.json();
    if (j && j[0]) return {lat: +j[0].lat, lon: +j[0].lon, name: j[0].display_name};
  } catch(e) { console.warn('geocode fail', e); }
  return null;
}

/* events + wiring */
async function onCheckClicked() {
  const v = document.getElementById('manual').value.trim();
  if (!v) return alert('Type a city or coordinates, or press "Use my location".');

  const saved = loadLocationFromStorage();
  const latlonRegex = /(-?\d+\.\d+)\s*,\s*(-?\d+\.\d+)/;
  const latlon = v.match(latlonRegex);
  if (latlon) {
    return await check(+latlon[1], +latlon[2], `${+latlon[1].toFixed(4)},${+latlon[2].toFixed(4)}`);
  } else if (saved && saved.name === v) {
    return await check(saved.lat, saved.lon, saved.name);
  } else {
    document.getElementById('output').style.display='block';
    document.getElementById('output').textContent='Resolving location‚Ä¶';
    const coords = await fetchCoordsFromText(v);
    if (!coords) {
      document.getElementById('output').innerHTML = '<span class="error">Could not resolve that location. Try "Chevy Chase, MD" or "38.9854,-77.0701".</span>';
      return;
    }
    document.getElementById('manual').value = coords.name;
    await check(coords.lat, coords.lon, coords.name);
  }
}
document.getElementById('btnCheck').addEventListener('click', onCheckClicked);

/* geo button */
document.getElementById('btnGeo').addEventListener('click', async ()=>{
  if (!navigator.geolocation) { alert('Geolocation not supported'); return; }
  document.getElementById('output').style.display='block'; document.getElementById('output').textContent='Locating‚Ä¶';
  navigator.geolocation.getCurrentPosition(async (pos)=>{
    const lat = pos.coords.latitude, lon = pos.coords.longitude;
    const displayName = `${lat.toFixed(4)},${lon.toFixed(4)}`;
    document.getElementById('manual').value = displayName;
    await check(lat, lon, displayName);
  }, (err)=>{
    alert('Location denied / failed. You can type your city or coords instead.');
    console.warn(err);
    document.getElementById('output').style.display='none';
  }, {timeout:10000});
});

/* prefill saved name on load */
window.addEventListener('DOMContentLoaded', ()=>{
  const saved = loadLocationFromStorage();
  if (saved) document.getElementById('manual').value = saved.name;
});

/* ICS maker helper */
function makeICS(dt) {
  function toUTCICS(d){
    const pad=(n)=>String(n).padStart(2,'0');
    return d.getUTCFullYear()+pad(d.getUTCMonth()+1)+pad(d.getUTCDate())+'T'+pad(d.getUTCHours())+pad(d.getUTCMinutes())+pad(d.getUTCSeconds())+'Z';
  }
  const start = toUTCICS(dt);
  const end = toUTCICS(new Date(dt.getTime()+20*60000));
  const uid = 'pink-sky-'+Date.now()+'@local';
  const summary = 'Pink-sky check (photos!)';
  const body = 'Sunset + 10 minutes ‚Äî check the sky for pink/blue afterglow.';
  return `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//pink-sky-checker//EN
BEGIN:VEVENT
UID:${uid}
DTSTAMP:${start}
DTSTART:${start}
DTEND:${end}
SUMMARY:${summary}
DESCRIPTION:${body}
END:VEVENT
END:VCALENDAR`;
}
</script>
</body>
</html>