<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pink Sky Checker</title>
<style>
  *,*::before,*::after{box-sizing:border-box}
  html,body{height:100%;margin:0;padding:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#071425}

  :root{
    --bg-top:#f4f9ff; --bg-bottom:#fff3fb; --card:#ffffff; --muted:#6b7280;
    --pink:#ff78b6; --purple:#b08bff; --blue:#6e9bff;
    --shadow-lg: 0 18px 40px rgba(8,18,40,0.10);
    --shadow-sm: 0 8px 22px rgba(8,18,40,0.06);
    --radius:14px;
    --pad: clamp(16px,4.4vw,36px);
    --content: 980px;
  }

  body{
    background: linear-gradient(180deg,var(--bg-top),var(--bg-bottom));
    padding: var(--pad);
    padding-left: max(var(--pad), env(safe-area-inset-left));
    padding-right: max(var(--pad), env(safe-area-inset-right));
    -webkit-font-smoothing:antialiased;
    line-height:1.45;
    overflow-x:hidden;
  }

  .title-wrap{max-width:var(--content);width:100%;margin:0 auto 14px}
  .title{
    display:inline-block;padding:10px 18px;border-radius:28px;
    background: linear-gradient(90deg, rgba(255,255,255,0.85), rgba(255,255,255,0.70));
    box-shadow: 0 10px 28px rgba(107,119,255,0.08), inset 0 1px 0 rgba(255,255,255,0.6);
    font-weight:900;font-size:clamp(26px,5.2vw,40px); color:transparent; -webkit-background-clip:text;
    background-image: linear-gradient(90deg,var(--pink),var(--purple),var(--blue));
    text-shadow: 0 6px 20px rgba(107,119,255,0.06);
  }

  .card{
    max-width:var(--content);width:100%;margin:0 auto;
    background:var(--card);border-radius:var(--radius);
    box-shadow:var(--shadow-lg);
    padding:clamp(14px,3.4vw,22px);
    border:1px solid rgba(8,15,40,0.04);
  }

  .lead{color:var(--muted);font-size:clamp(13px,2.1vw,15px);margin-bottom:8px}
  label{display:block;margin:8px 0 6px;font-weight:700;color:#051026}
  .row{display:flex;gap:10px;align-items:center}
  .row.col{flex-direction:column;align-items:stretch}
  input[type="text"]{flex:1;padding:11px;border-radius:12px;border:1px solid rgba(99,102,241,0.06);font-size:clamp(14px,2vw,16px)}
  select{padding:10px;border-radius:12px;border:1px solid rgba(99,102,241,0.06);background:white;font-size:clamp(14px,2vw,16px);min-width:170px}
  .btn{padding:12px 14px;border-radius:14px;border:0;color:white;font-weight:800;cursor:pointer;background: linear-gradient(90deg,var(--pink),var(--purple),var(--blue));box-shadow: var(--shadow-sm);min-width:88px}
  .btn.full{width:100%}

  /* result card with pill on top-right */
  .result{
    margin-top:14px;padding:14px 84px 14px 14px;
    border-radius:12px;position:relative;
    background:linear-gradient(180deg, rgba(245,251,255,0.95), rgba(255,248,252,0.95));
    border:1px solid rgba(99,102,241,0.05);font-size:clamp(14px,2vw,15px)
  }
  .pill{
    position:absolute;right:18px;top:18px;width:46px;height:46px;border-radius:999px;
    display:flex;align-items:center;justify-content:center;color:#fff;font-weight:900;
    box-shadow:0 10px 22px rgba(99,102,241,0.20);border:2px solid rgba(255,255,255,0.2)
  }
  .score-title{font-weight:900;font-size:clamp(16px,2.4vw,22px)}
  .verdict{font-weight:800;margin-top:6px;color:#243046}
  .tagline{color:var(--muted);font-size:clamp(12px,1.8vw,13px);margin-top:6px}
  .details{color:var(--muted);margin-top:8px;font-size:clamp(13px,1.8vw,14px)}
  .tiny{font-size:12px;color:var(--muted);margin-top:8px}

  /* Predicted colors */
  .colors{margin-top:12px}
  .colors-title{font-weight:800;margin-bottom:6px;color:#243046}
  .chips{display:flex;flex-wrap:wrap;gap:8px}
  .chip{
    padding:6px 10px;border-radius:999px;color:#fff;font-weight:800;font-size:13px;
    box-shadow:0 6px 18px rgba(99,102,241,0.12);border:2px solid rgba(255,255,255,0.22);
    white-space:nowrap
  }

  .extras{margin-top:10px}
  .extras a{color:#243046;text-decoration:underline}

  @media (max-width:720px){
    .row { gap:12px; flex-direction:column; align-items:stretch }
    .card { padding:16px }
    .title { font-size:28px }
  }

  footer{max-width:var(--content);width:100%;margin:20px auto 60px;color:var(--muted);text-align:center;font-size:13px}
</style>
</head>
<body>

  <div class="title-wrap"><div class="title">Pink Sky Checker</div></div>

  <div class="card" role="main" aria-labelledby="title">
    <div class="lead">Pick a location and day. Quick verdict + a single Photo-ready score (1–10).</div>

    <label for="manual">Location</label>
    <div class="row inline" style="margin-bottom:10px">
      <button id="btnGeo" class="btn">Use my location</button>
      <input id="manual" placeholder="Type a city or neighborhood (e.g. “Chevy Chase, MD”)" aria-label="Location input" />
      <select id="daySelect" title="Choose day" style="max-width:220px"></select>
    </div>

    <div style="margin-top:6px"><button id="btnCheck" class="btn full">Check</button></div>

    <div id="output" class="result" style="display:none" role="status" aria-live="polite"></div>

    <div id="after" style="display:none">
      <div id="colors" class="colors" style="display:none">
        <div class="colors-title">Predicted colors</div>
        <div id="chips" class="chips"></div>
      </div>
      <div class="extras" id="extras" style="display:none"></div>
      <div class="tiny" id="notes" style="display:none"></div>
    </div>
  </div>

  <footer>Made with soft gradients and stubborn optimism ☁️</footer>

<script>
/* storage & helpers */
const STORAGE_KEY='pinksky_saved_location';
function saveLocationToStorage(name,lat,lon){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify({name,lat,lon})); }catch(e){console.warn(e)} }
function loadLocationFromStorage(){ try{ const s=localStorage.getItem(STORAGE_KEY); if(!s) return null; const o=JSON.parse(s); if(o && typeof o.lat==='number'&&typeof o.lon==='number') return o;}catch(e){console.warn(e)} return null; }

function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
function weekdayShort(d){ return d.toLocaleDateString(undefined,{weekday:'short'}); }
function md(d){ return (d.getMonth()+1)+'/'+d.getDate(); }
function populateDaySelect(){ const sel=document.getElementById('daySelect'); sel.innerHTML=''; const now=new Date(); for(let i=0;i<7;i++){ const dt=addDays(now,i); const label=(i===0?'Today':(i===1?'Tomorrow':weekdayShort(dt)))+' ('+md(dt)+')'; const o=document.createElement('option'); o.value=''+i; o.textContent=label; sel.appendChild(o);} }
populateDaySelect();

function nearestIndex(timesISO,targetDate){ let best=0,bestD=1e12; for(let i=0;i<timesISO.length;i++){ const d=Math.abs(new Date(timesISO[i]).getTime()-targetDate.getTime()); if(d<bestD){bestD=d;best=i}} return best; }
function buildUrls(lat,lon){ const base=f=>`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=sunrise,sunset&hourly=${f}&timezone=auto`; return [base('cloudcover,cloudcover_high,cloudcover_mid,cloudcover_low,pm2_5'), base('cloudcover,pm2_5'), base('cloudcover')]; }
async function tryFetchUrls(urls){ for(const u of urls){ try{ const r=await fetch(u); const j=await r.json(); if(j && j.daily && j.hourly && j.hourly.time && j.hourly.time.length){ if(j.hourly.cloudcover || j.hourly.cloudcover===0) return j; } }catch(e){console.warn(e)} } return null; }

function scoreToScale(score){ const min=-2, max=6; const s=Math.max(min, Math.min(max, score)); const pct=(s-min)/(max-min); return Math.round(1 + pct*9); }
function scaleColor(n){ const t=(n-1)/9; const a=[255,120,182], b=[110,155,255]; const r=Math.round(a[0]+(b[0]-a[0])*t), g=Math.round(a[1]+(b[1]-a[1])*t), bl=Math.round(a[2]+(b[2]-a[2])*t); return `rgb(${r},${g},${bl})`; }
function airQualityLabel(pm2){ if(pm2==null) return null; if(pm2<=12) return 'Good'; if(pm2<=25) return 'Slight haze (nice)'; if(pm2<=40) return 'Moderate'; if(pm2<=60) return 'Hazy'; return 'Poor'; }

/* reverse geocode (for Use my location) */
async function reverseGeocode(lat,lon){
  try{
    const url = `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&addressdetails=1`;
    const r = await fetch(url, {headers:{'Accept-Language':'en'}});
    const j = await r.json();
    if(j && j.address){
      const a = j.address;
      const city = a.city || a.town || a.village || a.hamlet || a.county;
      const state = a.state || a.region || a.county;
      const postcode = a.postcode;
      let name = city ? (state ? `${city}, ${state}` : city) : (state ? state : (j.display_name || 'Your location'));
      if(postcode) name = `${name} ${postcode}`;
      return {name};
    }
  }catch(e){ console.warn('reverse fail', e); }
  return null;
}

/* geocode free text (no coordinate strings accepted) */
async function fetchCoordsFromText(text){
  try{
    const q = encodeURIComponent(text);
    const url = `https://nominatim.openstreetmap.org/search?q=${q}&format=json&limit=1`;
    const r = await fetch(url, {headers:{'Accept-Language':'en'}});
    const j = await r.json();
    if(j && j[0]) return {lat:+j[0].lat, lon:+j[0].lon, name:j[0].display_name};
  }catch(e){ console.warn('geocode fail', e); }
  return null;
}

/* ---------- NEW: windowed sampling & gentler scoring ---------- */
const avg = a => a.length ? a.reduce((x,y)=>x+y,0)/a.length : null;
const maxv = a => a.length ? Math.max(...a) : null;

function collectAtIndices(arr, idxs){ if(!arr) return []; return idxs.map(i => (typeof arr[i]==='number'? arr[i] : null)).filter(v => v!=null); }

function bestCheckShiftMinutes(clowAvg){
  if(clowAvg==null) return 10;
  if(clowAvg > 65) return 2;   // thicker low deck -> earlier
  if(clowAvg > 45) return 7;   // some low clouds -> a bit earlier
  return 12;                   // clearer horizon -> later afterglow
}

/* make nice color chips based on conditions */
function predictColorChips({rating, cloudAvg, chighMax, cmidMax, clowAvg, pm2Avg}){
  const chips = []; const add=(n,g)=>{ if(!chips.find(c=>c.name===n)) chips.push({name:n,grad:g}); };
  const haze = (pm2Avg!=null && pm2Avg>35);

  if ((cloudAvg!=null && cloudAvg>90) || (clowAvg!=null && clowAvg>70)) {
    add(haze?'smoky gray':'cool gray', 'linear-gradient(90deg,#9aa6b2,#c8d0d8)');
    add('slate blue','linear-gradient(90deg,#8aa0c9,#aebfe0)');
    return chips.slice(0,3);
  }
  if (chighMax!=null && chighMax>=20 && chighMax<=90){
    add(haze?'dusty rose':'hot pink','linear-gradient(90deg,#ff7ab9,#ff9cd3)');
    add(haze?'mauve':'lavender','linear-gradient(90deg,#c59bff,#d6b9ff)');
  }
  if (cmidMax!=null && cmidMax>=15 && cmidMax<=70){
    add(haze?'muted peach':'peach','linear-gradient(90deg,#ffb07a,#ffd7a3)');
  }
  if ((cloudAvg!=null && cloudAvg<=55) && (clowAvg==null || clowAvg<=55)) {
    add(haze?'steel blue':'periwinkle','linear-gradient(90deg,#7aa9ff,#b2c8ff)');
  }
  if (rating>=7){ add('magenta','linear-gradient(90deg,#ff3f9e,#ff77c8)'); }
  if (chips.length===0){ add('subtle rose','linear-gradient(90deg,#f9a7c1,#ffd0e2)'); add('soft blue','linear-gradient(90deg,#9bbdff,#c7d8ff)'); }
  return chips.slice(0,3);
}

/* main check */
async function check(lat,lon,displayName){
  const out=document.getElementById('output'); out.style.display='block'; out.textContent='Checking forecast…';
  document.getElementById('after').style.display='none';

  try{
    const urls=buildUrls(lat,lon);
    const json=await tryFetchUrls(urls);
    if(!json){ out.innerHTML=`<div style="color:var(--pink);font-weight:800">Forecast unavailable for that spot.</div>`; return; }
    const dayIndex=parseInt(document.getElementById('daySelect').value||'0',10);
    if(!json.daily || !json.daily.sunset || dayIndex>=json.daily.sunset.length){ out.innerHTML=`<div style="color:var(--pink);font-weight:800">No forecast for that day. Try a nearer day.</div>`; return; }

    const nameToSave = displayName || document.getElementById('manual').value.trim() || 'Saved location';
    saveLocationToStorage(nameToSave, lat, lon);

    const sunsetLocal = new Date(json.daily.sunset[dayIndex]);
    const times = json.hourly.time;
    const idx0 = nearestIndex(times, sunsetLocal);
    const idxM = nearestIndex(times, new Date(sunsetLocal.getTime()-60*60000));
    const idxP = nearestIndex(times, new Date(sunsetLocal.getTime()+60*60000));
    const idxs = [idxM, idx0, idxP];

    const clouds = collectAtIndices(json.hourly.cloudcover, idxs);
    const highs  = collectAtIndices(json.hourly.cloudcover_high, idxs);
    const mids   = collectAtIndices(json.hourly.cloudcover_mid, idxs);
    const lows   = collectAtIndices(json.hourly.cloudcover_low, idxs);
    const pm2s   = collectAtIndices(json.hourly.pm2_5, idxs);

    const cloudAvg = avg(clouds);
    const chighMax = maxv(highs);
    const cmidMax  = maxv(mids);
    const clowAvg  = avg(lows);
    const pm2Avg   = avg(pm2s);

    /* scoring */
    let score = 0;

    // total cloud: broken clouds = good
    if (cloudAvg!=null){
      if (cloudAvg >= 35 && cloudAvg <= 80) score += 2.0;
      else if ((cloudAvg >= 20 && cloudAvg < 35) || (cloudAvg > 80 && cloudAvg <= 90)) score += 0.8;
      else if (cloudAvg < 10) score -= 0.4;
      else if (cloudAvg > 90) score -= 1.0;
    }

    // high & mid clouds: stronger boost
    if (chighMax!=null){
      if (chighMax >= 20 && chighMax <= 90) score += 1.8;
      else if (chighMax > 90) score -= 0.4;
    }
    if (cmidMax!=null){
      if (cmidMax >= 15 && cmidMax <= 80) score += 1.4;
      else if (cmidMax > 85) score -= 0.3;
    }

    // low clouds: softer penalty; broken low deck is fine
    if (clowAvg!=null){
      if (clowAvg <= 35) score += 0.8;
      else if (clowAvg <= 60) score += 0.2;
      else score -= 0.8;
    }

    // PM2.5: slight haze helps, heavy hurts
    if (pm2Avg!=null){
      if (pm2Avg <= 8) score += 0.3;
      else if (pm2Avg <= 25) score += 0.6;
      else if (pm2Avg <= 40) score += 0.1;
      else if (pm2Avg <= 60) score -= 0.6;
      else score -= 1.2;
    }

    // verdict
    let shortText='', reason='';
    if (score >= 4.5) { shortText='Great chance of vivid colors'; reason='Broken mid/high clouds line up'; }
    else if (score >= 2.3) { shortText='Possible — might pop'; reason='Some high/mid clouds around'; }
    else { shortText='Unlikely to be vivid'; reason = (clowAvg!=null && clowAvg>60)?'Thick low clouds': (cloudAvg!=null && cloudAvg>90)?'Widespread overcast': (pm2Avg!=null && pm2Avg>40)?'Reduced visibility/haze':'Not favorable clouds'; }

    const bestShift = bestCheckShiftMinutes(clowAvg);
    const best = new Date(sunsetLocal.getTime() + bestShift*60000);
    const rating = scoreToScale(score);
    const pillColor = scaleColor(rating);

    const details = [];
    if (cloudAvg!=null) details.push(`Cloud ${Math.round(cloudAvg)}%`);
    if (chighMax!=null) details.push(`High ${Math.round(chighMax)}%`);
    if (cmidMax!=null)  details.push(`Mid ${Math.round(cmidMax)}%`);
    if (clowAvg!=null)  details.push(`Low ${Math.round(clowAvg)}%`);
    if (pm2Avg!=null)   details.push(`AQ: ${airQualityLabel(pm2Avg)}`);

    out.innerHTML = `
      <div class="pill" style="background:${pillColor}">${rating}</div>
      <div class="score-title">Photo-ready</div>
      <div class="verdict">${shortText}</div>
      <div class="tagline">${reason} · Best check ${best.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</div>
      <div class="details">${details.join(' · ')}</div>
      <div class="tiny">Sunset: ${sunsetLocal.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</div>
    `;

    // Predicted colors
    const chipBox = document.getElementById('chips');
    chipBox.innerHTML = '';
    const chips = predictColorChips({rating, cloudAvg, chighMax, cmidMax, clowAvg, pm2Avg});
    chips.forEach(c=>{ const el=document.createElement('span'); el.className='chip'; el.style.background=c.grad; el.textContent=c.name; chipBox.appendChild(el); });
    document.getElementById('colors').style.display='block';

    // Calendar reminder
    const ics = makeICS(best);
    const blob = new Blob([ics], {type:'text/calendar'});
    const urlBlob = URL.createObjectURL(blob);
    const extras = document.getElementById('extras');
    extras.innerHTML = `<a href="${urlBlob}" download="pink-sky-reminder.ics">📅 Add reminder</a>`;
    extras.style.display='block';

    document.getElementById('after').style.display='block';
    document.getElementById('notes').style.display='block';
    document.getElementById('notes').textContent = 'Score is 1–10 photo-readiness (1 = unlikely, 10 = very likely).';

  }catch(err){ console.error(err); out.innerHTML=`<div style="color:var(--pink);font-weight:800)">Error fetching forecast — try again.</div>`; }
}

/* actions */
async function onCheckClicked(){
  const v=document.getElementById('manual').value.trim();
  if(!v) return alert('Type a city or neighborhood (e.g. "Chevy Chase, MD") or press "Use my location".');
  document.getElementById('output').style.display='block'; document.getElementById('output').textContent='Resolving location…';
  const coords = await fetchCoordsFromText(v);
  if(!coords){ document.getElementById('output').innerHTML=`<div style="color:var(--pink);font-weight:800">Could not find that place. Try "Chevy Chase, MD" or a nearby city.</div>`; return; }
  const label = coords.name || v;
  document.getElementById('manual').value = label;
  await check(coords.lat, coords.lon, label);
}
document.getElementById('btnCheck').addEventListener('click', onCheckClicked);

document.getElementById('btnGeo').addEventListener('click', async ()=>{
  if(!navigator.geolocation){ alert('Geolocation not supported'); return; }
  document.getElementById('output').style.display='block'; document.getElementById('output').textContent='Locating…';
  navigator.geolocation.getCurrentPosition(async (pos)=>{
    const lat=pos.coords.latitude, lon=pos.coords.longitude;
    const rev = await reverseGeocode(lat,lon);
    const label = rev && rev.name ? rev.name : 'Your location';
    document.getElementById('manual').value = label;
    await check(lat,lon,label);
  }, (err)=>{ alert('Location denied/failed. You can type your city or neighborhood instead.'); console.warn(err); document.getElementById('output').style.display='none'; }, {timeout:10000});
});

/* prefill saved name */
window.addEventListener('DOMContentLoaded', ()=>{
  const saved = loadLocationFromStorage();
  if(saved) document.getElementById('manual').value = saved.name;
});

/* ICS maker */
function makeICS(dt){
  function toUTCICS(d){ const pad=n=>String(n).padStart(2,'0'); return d.getUTCFullYear()+pad(d.getUTCMonth()+1)+pad(d.getDate())+'T'+pad(d.getUTCHours())+pad(d.getUTCMinutes())+pad(d.getUTCSeconds())+'Z'; }
  const start=toUTCICS(dt);
  const end=toUTCICS(new Date(dt.getTime()+20*60000));
  const uid='pink-sky-'+Date.now()+'@local';
  const summary='Pink-sky check';
  const body='Sunset +10 minutes — check for afterglow.';
  return `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//pink-sky//EN
BEGIN:VEVENT
UID:${uid}
DTSTAMP:${start}
DTSTART:${start}
DTEND:${end}
SUMMARY:${summary}
DESCRIPTION:${body}
END:VEVENT
END:VCALENDAR`;
}
</script>
</body>
</html>